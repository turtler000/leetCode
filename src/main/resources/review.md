这里放的是（~~写代码也用不到~~）很容易忘记的知识，看了很多遍还是记不住，要多看多背。

### 一、基础知识

1.事务具有四大特性： **1. 原子性**，**2. 隔离性**，**3. 持久性**，**4. 一致性**。

原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；

隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；

持久性（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

一致性（Consistency）：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；

2.二叉查找树

​	AVL树:带有平衡条件的二叉查找树

​	红黑树

​	B/B+树：平衡多路查找树。

​					区别：B+树只有叶子节点存储数据（其他太复杂略）

3.乐观锁悲观锁

乐观锁：处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。 实现：1.CAS 实现 2.版本（innodb)

悲观锁是数据库层面加锁，都会阻塞去等待锁


作者：Java3y
链接：https://juejin.cn/post/6844903645125820424
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 二、java基础

#### 1.basic

1.重载overload 重写override

​	重载发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

​	重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

​	构造方法不能被 override（重写）,但是可以 overload（重载）

2.当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。

3.使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作，避免精度丢失

4.`Arrays.asList()`将数组转换为集合后,底层其实还是数组，使用下边这个

```
List list = new ArrayList<>(Arrays.asList("a", "b", "c"))
```

5.动态代理：实现InvocationHandler接口中的invoke()方法

6.获取class对象方式

```
Class alunbarClass = TargetObject.class;

Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");

TargetObject o = new TargetObject();
Class alunbarClass2 = o.getClass();

class clazz = ClassLoader.LoadClass("cn.javaguide.TargetObject");
```

#### 2.collection

1.ArrayList和vector

`ArrayList` 是 `List` 的主要实现类，适用于频繁的查找工作，线程不安全 ；

`Vector` 是 `List` 的古老实现类，底层使用 `Object[ ]`存储，线程安全的。

2.ArrayList和LinkedList

​	都线程不安全

​	ArrayList数组，方便查询不方便插入；LinkedList 双向链表，方便插入不方便查询。

​	空间：ArrayList结尾需要预留，LinkedList 每个元素都比ArrayList多（要放前后指针）

3.ArrayList 扩容

​	默认为10，扩容使用grow()方法， 每次扩容之后容量都会变为原来的 1.5 倍，如果是奇数的话会丢掉小数



### 三、Database

#### 1.mysql

1.索引最左匹配原则：

索引可以简单如一个列`(a)`，也可以复杂如多个列`(a, b, c, d)`，即**联合索引**。

如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否**存在（相等）**，遇到范围查询`(>、<、between、like`左匹配)等就**不能进一步匹配**了，后续退化为线性查找。会自动优化=，in。

因此，**列的排列顺序决定了可命中索引的列数**。

2.InnoDB只有通过**索引条件**检索数据**才使用行级锁**，否则，InnoDB将使用**表锁**

3.表锁：

表读锁（Table Read Lock）

表写锁（Table Write Lock）

- 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁
- 读写阻塞：当前用户在读数据，其他的用户**不能修改当前用户读的数据**，会加锁！
- 写写阻塞：当前用户在修改数据，其他的用户**不能修改当前用户正在修改的数据**，会加锁！

4.行锁

共享锁（S锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。

- 也叫做**读锁**：读锁是**共享**的，多个客户可以**同时读取同一个**资源，但**不允许其他客户修改**。

排他锁（X锁)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

- 也叫做**写锁**：写锁是排他的，**写锁会阻塞其他的写锁和读锁**。

5.事务问题

​	丢失修改（Lost to modify）

​	脏读（Dirty read）：一个事务读取到另外一个事务未提交的数据.

​	不可重复读（Unrepeatableread）:当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据

​	幻读（Phantom read）：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。

​	不可重复读和幻读比较：前者针对的是update或delete，后者针对的insert

6.事务的隔离级别

​	Read uncommitted:  脏读，不可重复读，幻读

​	Read committed:  不可重复读，幻读

​	Repeatable read:  幻读

​	Serializable:串行

7.一些性能问题：

​	避免数据类型的隐式转换

​	禁止使用 SELECT * 必须使用 SELECT <字段列表> 查询

​	禁止使用不含字段列表的 INSERT 语句

​	对应同一列进行 or 判断时，使用 in 代替 or

​	不用字符串存储日期

#### 2.redis

1.Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性），Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断

2.缓存穿透，大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层

解决：1.缓存无效 key (黑名单)

​			2.布隆过滤器

3.缓存雪崩，缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求

解决：失效时间

4.缓存击穿，缓存击穿跟缓存雪崩类似，区别就是缓存雪崩是群体失效，缓存击穿是单体失效。**在系统从后端DB加载数据到缓存这个过程中**，这段时间超大并发的请求会同时打到DB上，很有可能瞬间把DB压垮。

解决：互斥锁，就是在缓存失效的时候，不是直接请求DB，而是先加分布式锁（比如redis的setNx），如果加锁成功，再进行load db的操作并回设缓存；如果加锁失败，说明已经有别的进程在加锁重设缓存，我们只需要等待重试或者直接返回客户端失败让用户手动重试

5.一致性方案

一般方案：先写MySQL数据库，再删除Redis缓存；先删除缓存，再写库。都有可能数据不一致

稳定方案：1.延时双删，在写库前后都进行redis.del(key)操作，db.update后等待500ms。

​					2.异步更新缓存(基于订阅binlog的同步机制),MySQL binlog增量订阅消费+消息队列+增量数据更新到redis

### 操作系统

1.常用linux命令

​	top:显示当前正在执行的进程的CPU使用率