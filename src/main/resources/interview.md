这里放的是面试中问到的问题，每次都进行记录和答案整理
目前简历投递情况：
2021/5/10  
华为 
哈啰出行
贝克找房
猿辅导
BOSS
震坤行

| 公司     | 状况   | 面试 | 强度 | 谈薪 |
| -------- | ------ | ---- | ---- | ---- |
| 华为     | 投简历 |      |      |      |
| 哈啰出行 |        | 一面 |      |      |
| 贝克找房 |        |      |      |      |
| 猿辅导   |        |      |      |      |
| BOSS     |        | 一面 |      |      |
| 震坤行   |        |      |      |      |
|          |        |      |      |      |

### 面试

#### boss直聘  2021/5/14 周四

笔试：

两道算法题

线程交替打印大小写字母，1-100质数阶乘求和

1.23枚硬币，10枚正面，闭眼无法区分正反面，分两组，怎么保证2组正面数量一样（提示：分组的时候可以翻转硬币）

2.若a=b-2且 ab都为质数，求证a+1被6整除

一面

手写快排

快速排序的最优时间复杂度是 O(nlogn)，最差时间复杂度是 O(n2)，期望时间复杂度是 O(nlogn)。

空间复杂度，最好logn ，最坏n,平均 logn

```
quickSort(int[] nums,int left ,int right){
if(left>=right){
return;
}
int basic = nums[left];
int l = left;
int r = right;
while(left<right){
while(nums[right]>basic&&right!=left){
right --;
}
while(nums[left]<basic&&left!=right){
left ++;
}
if(left!=right){
swap(nums[left],nums[right]);
}
}
swap(nums[left],basic);
quickSort(nums,l,left-1);
quickSort(nums,right+1,r);
}
```

3、10w个数求前10个

分组 

堆排序 初始化n，每次重新构建，时间复杂度nlogn，就地排序，空间复杂度O(1)

4、数据库索引，建立原则，

1. 定义主键的数据列一定要建立索引。
2. 定义有外键的数据列一定要建立索引。
3. 对于经常查询的数据列最好建立索引。
4. 对于需要在指定范围内的快速或频繁查询的数据列;
5. 经常用在WHERE子句中的数据列。
6. 经常出现在关键字order by、group by、distinct后面的字段，建立索引。如果建立的是复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致，否则索引不会被使用。
7. 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
8. 对于定义为text、image和bit的数据类型的列不要建立索引。
9. 对于经常存取的列避免建立索引
10. 限制表上的索引数目。对一个存在大量更新操作的表，所建索引的数目一般不要超过3个，最多不要超过5个。索引虽说提高了访问速度，但太多索引会影响数据的更新操作。
11. 对复合索引，按照字段在查询条件中出现的频度建立索引。在复合索引中，记录首先按照第一个字段排序。对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用,因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能地使用此索引，发挥索引的作用。

5、数据库事务特性

acid 原子性 一致性 隔离性 持久性

6、死锁，如何避免死锁

1. 加锁顺序（线程按照一定的顺序加锁）
2. 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）
3. 死锁检测

7、java8特性

lambda表达式

 **@Repeatable** 注解定义重复注解

8、数据库锁

9、jvm垃圾回收算法，垃圾回收器

标记-清除、复制算法、标记-整理算法、

新：

Serial收集器，单线程、简单高效（与其他收集器的单线程相比）收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束。

ParNew收集器其实就是Serial收集器的多线程版本。

Parallel Scavenge 收集器，新生代收集器也是采用复制算法的收集器，又是并行的多线程收集器（与ParNew收集器类似）。

老：

Serial Old是Serial收集器的老年代版本。

是Parallel Scavenge收集器的老年代版本，标记-整理算法。

CMS 一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现。并发收集、低停顿。

总:G1

并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。

分代收集：G1能够独自管理整个Java堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。

空间整合：G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。

可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。

10、@autowired @resource区别

​	@Autowired注解由Spring提供，只按照byType注入；@resource注解由J2EE提供，默认按照byName自动注入。

​	@Autowired默认按类型进行装配，@Resource默认按照名称进行装配。

#### 哈啰单车

一面

问项目

目前没答上来的，印象深刻的

1.为什么用线程池而不是显示创建线程，



线程池参数

2.springcloud-gateway 熔断降级

3.rabbitmq 队列的前后顺序 性能问题

#### 贝克找房 2021/5/14 周五

redis 作用

rabbitmq 消息重复，消息堆积，消息顺序

数据库 事务，如何保证，MVCC,日志

分库分表

#### 2021/5/17 周一

目前面试了三家，总结需要的问题

1.简单的问题不熟练

2.社招需要更多的高并发高可用经验

需要进行的学习：

1.消息队列，视频，面经，一定做到彻底熟悉

2.数据库，索引，锁，MVCC熟练背诵而不是自己说，分库分表看视频，复杂业务场景解析

